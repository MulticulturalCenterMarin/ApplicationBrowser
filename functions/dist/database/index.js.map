{"version":3,"sources":["../../src/database/index.js"],"names":["admin","require","databaseSearch","entity","branch","boundaries","order","Promise","database","ref","join","orderByKey","pathReference","orderByChild","orderByValue","limitToFirst","limitToLast","startAt","endAt","equalTo","on","snapshot","dataNew","push","val","reject","Error","once","resolve","reverse","databaseRead","databaseReadSingle","databaseWrite","payload","config","entityCorrect","writeType","objectReference","console","log","objectDatabaseReference","update","pointer","message","e","set","isObject","prototype","toString","obj","toArray","forEach","childSnapshot","id","key","arr","filter","entityMatch","typeCorrect","type","dataWriteTypeMatch","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["/* ------------------------ External Dependencies ------------------------ */\nimport _ from 'lodash'\nconst admin = require('firebase-admin');\n/* ------------------------------- Database --------------------------------- */\nconst databaseSearch = ({entity, branch = [], boundaries = {}, order = {} }) => new Promise((resolve, reject) => {\n  const dataNew = []\n  let pathReference = admin.database().ref(`/${entity}/${_.join(branch, '/')}`);\n\n  /*--- ref.orderByKey ---*/\n  if (order && order.orderByKey) {\n    pathReference = pathReference.orderByKey()\n  }\n\n  // ref.orderByChild()\n  if (order && order.orderByChild) {\n    pathReference = pathReference.orderByChild(order.orderByChild)\n  }\n\n  // ref.orderByValue()\n  if (order && order.orderByValue) {\n    pathReference = pathReference.orderByValue(order.orderByValue)\n  }\n\n  /*--- Boundaries ---*/\n\n  // ref.limitToFirst() | https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference#limitToFirst\n  if (boundaries && boundaries.limitToFirst && boundaries.limitToFirst < 500) {\n    pathReference = pathReference.limitToFirst(boundaries.limitToFirst)  \n  }\n  // ref.limitToLast() | https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference#limitToFirst\n  if (boundaries && boundaries.limitToLast && boundaries.limitToLast < 500) {\n    pathReference = pathReference.limitToLast(boundaries.limitToLast)  \n  }\n  // ref.startAt() | https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference#limitToFirst\n  if (boundaries && boundaries.startAt) {\n    pathReference = pathReference.startAt(boundaries.startAt)  \n  }\n  // ref.endAt() | https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference#limitToFirst\n  if (boundaries && boundaries.endAt) {\n    pathReference = pathReference.endAt(boundaries.endAt)  \n  }\n  // ref.equalTo() | https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference#limitToFirst\n  if (boundaries && boundaries.equalTo) {\n    pathReference = pathReference.equalTo(boundaries.equalTo)  \n  }\n\n  /*--- Filter Database ---*/\n  pathReference.on('child_added', (snapshot,childKey) => {\n    return snapshot\n    ? dataNew.push(snapshot.val())\n    : reject(new Error(`Firebase Error: the admin.database.ref in databaseSearch() is originating the error.`))\n  });\n\n  /**\n   * Resolve Database Read\n   * ref.once('value', ...) is run after all ref.on('child_added', ...) events have occured.\n   * This implied request order is \"guaranteed\" by Firebase and doesn't require another request,\n   * because caching will return values to the final request to resolve the database read.\n   * \n   * Related Information - Answer by Firebase Core Developer\n   * https://stackoverflow.com/questions/27978078/how-to-separate-initial-data-load-from-incremental-children-with-firebase/27995609#27995609\n   * \n   */\n  pathReference.once('value', function(snapshot) {\n    resolve(order && order.reverse ? dataNew.reverse() : dataNew)\n  });\n\n});\n\nconst databaseRead = ({entity, branch = [], boundaries = {}, order = {} }) => new Promise((resolve, reject) => {\n  const dataNew = []\n  let pathReference = admin.database().ref(`/${entity}/${_.join(branch, '/')}`);\n\n  pathReference.once('value', function(snapshot) {\n    resolve(snapshot.val())\n  });\n\n});\nconst databaseReadSingle = ({entity, branch = [], boundaries = {}, order = {} }) => new Promise((resolve, reject) => {\n  const dataNew = []\n  let pathReference = admin.database().ref(`/${entity}/${_.join(branch, '/')}`);\n\n  pathReference.once('value', function(snapshot) {\n    resolve(snapshot.val())\n  });\n\n});\n\n/**\n * databaseWrite \n * @const {String} entity \n * @const {Array/Object} array \n * @const {Object} payload \n * @const {Object} metdata\n * \n * @desc metadata.config\n *  @var writeType - [push, update, set]\n */\nfunction databaseWrite({ entity, branch = [], payload = {}, config = {}, boundaries = {}, order = {} }) {\n  // Validate Query\n  if (!entityCorrect(entity)) return false \n\n  let pathReference = admin.database().ref(`${entity}/${_.join(branch, '/')}`);\n  switch(config.writeType) {\n\n    // Push | writeType\n    case'push':\n      try {\n        const objectReference = pathReference.push({\n          ...payload\n        })\n\n        let objectDatabaseReference = admin.database().ref(`${entity}/${_.join(branch, '/') + \"/\" + objectReference }`);\n        console.log(objectReference)\n        console.log(objectDatabaseReference)\n        objectDatabaseReference.update({pointer: objectReference})\n\n        // Return object's unique identifier (ex: KqOZV5OSevQaZz3KcxK)\n        return objectReference\n      } catch(e) {\n        return {message: e.message}\n      }\n    break;\n    // Update | writeType\n    case'update':\n      try {\n        const objectReference = pathReference.update({...payload})\n        return objectReference\n      } catch(e) {\n        return {message: e.message}\n      }\n    break;\n    // Set | writeType\n    case'set':\n      try {\n        const objectReference = pathReference.set({...payload})\n        // Return Promise containing void \n        return objectReference\n        } catch(e) {\n          return {message: e.message}\n        }\n      break;\n    default:\n      return {message: 'error: databaseWrite failed because writeType default is null. Please select push, update or set.'}\n\n  }\n\n}\n\n/* --------------------------- Utility Functions  --------------------------- */\nconst isObject = obj => {\n  return Object.prototype.toString(obj) === '[object Object]' ? true : false;\n};\n\nconst toArray = snapshot => {\n  console.log(snapshot)\n  let arr = [];\n  snapshot.forEach(childSnapshot => {\n    let val = childSnapshot.val();\n    if(isObject(val)){\n      val.id = childSnapshot.key;\n    }\n    arr.push(val);\n  });\n  return arr;\n};\n\n/**\n * @func entityCorrect\n * @desc Confirm the database write contains a valid entity in the application database schema.\n */\nconst entityCorrect = (entity) => [\n  'self', \n  'community', \n  'organization', \n  'infrastructure',\n  'mutate',\n  ].filter((entityMatch) => entity === entityMatch ? true : false)\n\n/**\n * @func typeCorrect\n * @desc Confirm the database write contains a valid database write type before attempting a database change.\n */\nconst typeCorrect = (type) => ['create', 'update', 'patch'].filter((dataWriteTypeMatch) => type === dataWriteTypeMatch ? true : false)\n\nmodule.exports = {\n  databaseRead,\n  databaseReadSingle,\n  databaseWrite\n}\n\n\n"]}